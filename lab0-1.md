# 实验一

## lab0.5 最小可执行内核和启动流程

### 练习1：使用GDB验证启动流程

问题：为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答

#### 实验过程

首先需要在lab0下面打开两个终端，一个终端输入“make debug”，一个终端输入“make gdb”。此时就进入了gdb调试。  

输入“x/10i $pc ”查看即将要执行的十条汇编指令

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/1.png?raw=true)

```
0x1000: auipc t0,0x0` # t0 = pc + 0 << 12 = 0x1000
```

可以看到，现在指向的地址的0x1000，输入“ni”让程序往下执行一步  

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/2.jpg?raw=true)

可以看到现在程序指向的地址变成0x1004。  

输入“info r t0”，查看寄存器t0的值，再输入“ni”往下执行一步，查看寄存器a1的值。由于执行了指令`addi    a1,t0,32` ，所以a1的值应该是t0寄存器中的值加32，显示正确。  

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/3.jpg?raw=true)

```
csrr a0,mhartid # a0 = mhartid = 0`

`ld t0,24(t0) # t0 = [t0 + 24] = 0x80000000`

`jr t0 # 跳转到地址0x80000000`
```

输入“x/10i 0x80000000” : 显示 0x80000000 处的10条汇编指令。  该地址处加载的是作为bootloader的`OpenSBI.bin`，该处的作用为加载操作系统内核并启动操作系统的执行。

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/4.jpg?raw=true)

```
csrr a6,mhartid # a6 = mhartid (获取当前硬件线程的ID)
bgtz a6,0x80000108 # 如果 a6 > 0，则跳转到0x80000108
auipc t0,0x0 # t0 = pc + (0x0 << 12) = 0x80000008
addi t0,t0,1032 # t0 = t0 + 1032 = 0x80000408
auipc t1,0x0 # t1 = pc + (0x0 << 12) = 0x80000010
addi t1,t1,-16 # t1 = t1 - 16 = 0x80000000
sd t1,0(t0) # 将t1的值（0x80000000）存储在地址0x80000408处
auipc t0,0x0 # t0 = pc + (0x0 << 12) = 0x8000001c
addi t0,t0,1020 # t0 = t0 + 1020 = 0x80000400
d t0,0(t0) # t0 = [t0 + 0] = [0x80000400] (从地址0x80000400加载一个双字到t0)`
```

输入“b *0x80000000”，在0x80000000处打一个断点，然后输入“c”，执行直到碰到断点。  

输入“x/10i $pc ”查看即将要执行的十条汇编指令。 可以看到地址是指向0x80000000的，说明执行到了打的断点处，从这个地址开始执行接下来的指令。与上面“x/10i 0x80000000” 指令执行之后显示一致。  

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/5.jpg?raw=true)

输入“b *0x80200000”，在0x80200000处打一个断点，输入“c”，执行直到碰到断点。此时就进入了`kern_init`函数（`0x80200000`处是`kern_init`函数的入口点，地址`0x80200000`由`kernel.ld`中定义的`BASE_ADDRESS`（加载地址）所决定，标签`kern_entry`是在`kernel.ld`中定义的`ENTRY`（入口点））。这个时候发现在“make debug”的终端窗口进行了输出 ，说明OpenSBI已经成功启动。

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/6.jpg?raw=true)

#### 实验总结

从机器启动到操作系统运行的过程

最小可执行内核的执行流为:

加电 -> OpenSBI启动 -> 跳转到 0x80200000 (`kern/init/entry.S`）->进入`kern_init()`函数（`kern/init/init.c`) ->调用`cprintf()`输出一行信息->结束

重要操作系统原理知识点包括：

1. Qemu模拟器的启动流程：了解Qemu模拟器的启动流程，包括与操作系统对接、程序内存布局和编译流程等相关知识。

2. 内核的最小可执行形式：了解内核的最小可执行形式，即操作系统的核心功能和结构。

3. Opensbi固件的使用：了解通过Opensbi固件来与服务进行通信的方法。

这些知识点与操作系统原理中的相关知识点有以下关联：

1. 操作系统启动流程：了解Qemu模拟器的启动流程可以帮助理解操作系统的启动流程，包括加载内核、初始化硬件等步骤。

2. 操作系统的内核结构：通过了解内核的最小可执行形式，可以更好地理解操作系统的核心功能和结构，如中断处理、内存管理、进程管理等。

3. 操作系统与硬件的交互：通过Opensbi固件的使用，可以了解操作系统与硬件之间的交互方式，如中断处理、设备驱动等。

## lab1 中断处理机制

### 练习1：理解内核启动中的程序入口操作

问题：阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

`kern/init/entry.S`中的汇编代码实现了进入内核的入口点。现在这个入口点，作用就是分配好内核栈，然后跳转到`kern_ini`。栈是用于存储函数调用和局部变量的内存区域。在操作系统内核的启动过程中，需要一个初始化的栈来执行初始化和设置阶段的工作。这个初始化栈是在操作系统内核的启动代码中创建的，通常位于内存中的一个特定位置。

通过汇编知识，可以知道sp表示栈的栈顶指针，用于跟踪当前线程或进程的栈的顶部。`la` 是 MIPS 汇编中的伪指令，用于将一个立即数加载到寄存器中。

指令`la sp, bootstacktop`中，将立即数（`bootstacktop`） 的值加载到 `sp` 寄存器中，从而指定了内核使用的初始栈的位置。确保了在内核启动期间操作系统可以在正确的栈上执行必要的操作，而不会发生栈溢出或其他问题。

指令`tail kern_init`是实现一个函数调用（尾调用），它将程序的控制流从当前位置跳转到 `kern_init` 函数（因为`kern_init`函数才是我们程序真正的入口点）。这说明操作系统的执行将从 `kern_init` 函数开始。

### 练习2：完善中断处理

根据提示，完成代码的编写：

```
clock_set_next_event();
ticks++; #计数器（ticks加一）
if(ticks == 100) #当计数器加到100的时候
if(ticks == 100) #当计数器加到100的时候
{
 print_ticks(); #输出一个“100 ticks”表示触法了100次时钟中断，同时打印
 ticks = 0;
 num++; #打印次数+1
}
if(num == 10) #判断打印次数，当打印次数为10时
{
 sbi_shutdown(); #调用<sbi.h>中的关机函数关机
}`
```

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/code.png?raw=true)

编写完成代码之后，进行测试。

`make qemu`

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/8.png?raw=true)

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/7.png?raw=true)

`make grade`

![](https://github.com/123WangSiyu456/oswork/blob/master/picture/lab1/9.png?raw=true)

### 扩展练习 Challenge1：描述与理解中断流程

产生一次时钟中断的执行流：set_sbi_timer()通过OpenSBI的时钟事件触发一个中断，跳转到`kern/trap/trapentry.S`的`__alltraps`标记 -> 保存当前执行流的上下文，并通过函数调用，切换为`kern/trap/trap.c`的中断处理函数`trap()`的上下文，进入`trap()`的执行流。切换前的上下文作为一个结构体，传递给`trap()`作为函数参数 -> `kern/trap/trap.c`按照中断类型进行分发(`trap_dispatch(), interrupt_handler()`)->执行时钟中断对应的处理语句，累加计数器，设置下一次时钟中断->完成处理，返回到`kern/trap/trapentry.S`->恢复原先的上下文，中断处理结束。

sp是栈顶指针，`mov a0，sp`代表将sp指针寄存器中的值保存到a0寄存器。这样做是为了备份当前的栈指针，以便在处理完中断或异常后，能够找到正确的栈位置来恢复上下文。

`SAVE_ALL` 是一个宏，用于保存所有寄存器的值到当前的内核栈上。寄存器保存的位置是由结构体`trapframe`和`pushregs`中的定义顺序决定的，因为后续这些寄存器都要作为函数`trap`的参数的具体内容。

对于任何中断，__alltraps 中都需要保存所有寄存器。因为处理中断或异常时，需要保证上下文的完整性，以便在处理完成后能够正确地恢复执行。特别是一些特定的异常处理需要使用到保存在其他特殊寄存器中的值，因此需要保存所有寄存器的状态。这样可以确保系统在处理中断或异常时的正确性和一致性。

### 扩增练习 Challenge2：理解上下文切换机制

csrw sscratch, sp；#将当前栈指针(`sp`)的值存储到寄存器`sscratch` 中。

csrrw s0, sscratch, x0; #将 `sscratch` 寄存器中的值加载到寄存器 `s0` 中，并将 `x0` 寄存器的值存储到 `sscratch` 中。此操作实际上是通过交换 `s0` 和 `sscratch` 的值，将 `s0` 寄存器的值存储到 `sscratch` 中。

为了在中断或异常处理中保存和恢复相关的上下文，并确保在处理完成后可以正确地恢复执行状态。

CSR（控制状态寄存器）：在 `SAVE_ALL` 部分，一些 CSR（如 `stval`、`scause` 等）被保存到内核栈上，以存储当前中断或异常的相关信息。在 `RESTORE_ALL` 部分，没有针对 `stval` 和 `scause` 等 CSR 进行特别的还原操作。是因为在正常的处理流程中，这些 CSR 的值不会由异常处理程序修改。因此，在正常的情况下，使用保存在内核栈上的原始值即可。其实这些 CSR 的值仍然存储在内核栈中，如果在异常处理程序中需要访问它们，可以通过加载内核栈上保存的原始值来恢复。只有当异常处理程序需要修改这些 CSR 的值时，才会执行相应的还原操作。

### 实验总结

重要操作系统原理知识点包括：

1. 中断处理机制：lab1涉及到操作系统如何处理中断。这与操作系统原理中的中断处理机制有关，包括中断向量表、中断处理程序、中断控制器等。

2. 上下文切换：lab1中介绍了操作系统在处理中断时如何保存和恢复上下文环境。这与操作系统原理中的上下文切换有关，包括保存和恢复寄存器、堆栈切换等。

3. 中断向量表：lab1中涉及到中断向量表的设置和使用。这与操作系统原理中的中断向量表有关，用于将中断号映射到相应的中断处理程序。

4. 时钟中断：lab1中使用时钟中断来检验中断处理系统。这与操作系统原理中的时钟中断有关，用于定时触发操作系统的调度和其他操作。

通过实验1的学习和实践，可以加深对这些操作系统原理中的知识点的理解和应用。同时，实验1也为后续实验提供了基础，如实验2中的物理内存管理和实验3中的虚拟内存管理等。
